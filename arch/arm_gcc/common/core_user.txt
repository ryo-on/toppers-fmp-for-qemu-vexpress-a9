=====================================================================
                   ARMプロセッサ依存部マニュアル
                                  Last Modified: 2012 Oct 19 17:12:05
=====================================================================

○概要

ARM にはアーキテクチャーバージョンが幾つか存在する．本カーネルでは，
ARMv4 以上のアーキテクチャーをサポートすることとする．基本的には，
ARMv4 を前提として記述している．しかしながら，上位のアーキテクチャでは
記述方法を変更することによって性能向上を図れる箇所が存在する．そのよう
な箇所については，条件コンパイルによって対応することにする．


○開発環境

コンパイラは，gccを用いる．動作確認を行ったバージョンは，CodeSourcery
でリリースされているGNU C/C++である．


○CPU例外の取り扱い

●例外とPCの関連

例外                              モード      アドレス   戻り先PC
リセット             Reset          svc      0x00000000
未定義命令           Undefined      und      0x00000004    lr(コプロはpc-4)
SWI                  Software Int   swi      0x00000008    lr(次の命令)
プリフェッチアボート Prefetch Abort abt      0x0000000C    lr-4(再実行)
データアボード       Data Abort     abt      0x00000010    lr-8(再実行)
IRQ                  IRQ            irq      0x00000018    lr-4(次の命令)
FIQ                  FIQ            fiq      0x0000001C    lr-4(次の命令)

ARMは，例外毎に戻り番地が異なり，例外の要因になった命令を再実行するか
どうかによっても戻り番地が異なる．そのため，カーネルの例外ハンドラでは，
戻り先のPCは操作せず．戻り先のPCを設定させる機能を提供する．ユーザは
CPU例外ハンドラでこれらの機能を用いて戻り先のアドレスを設定する．

      uint32_t x_get_exc_raddr(void *p_excinf);

      void x_set_exc_raddr(void *p_excinf, uint32_t pc);

● CPU例外ハンドラ番号

例外毎に番号をつける．0番,5番にはユーザーは例外ハンドラを登録できない．

 リセット             0
 未定義命令           1
 SWI                  2
 プリフェッチアボート 3
 データアボード       4
 IRQ                  5
 FIQ                  6

●ベクターテーブル

ARMのベクタ（vector_table）は，ARMのベクタアドレス0x00000000から配置す
る．vector_ref_tblは，例外発生時のジャンプ先のテーブルで，vector_tble
の命令から参照される．

    .section .vector,"a"
    .global vector_table
vector_table:
    ldr pc, reset_vector       /* リセット             */
    ldr pc, undef_vector       /* 未定義命令           */
    ldr pc, swi_vector         /* ソフトウェア割込み   */
    ldr pc, prefech_vector     /* プリフェッチアボード */
    ldr pc, data_abort_vector  /* データアボード       */
    ldr pc, reset_vector
    ldr pc, irq_vector         /* IRQ                  */
    ldr pc, fiq_vector         /* FIQ                  */

    .align  2
    .global vector_ref_tbl
vector_ref_tbl:
reset_vector:
    .long   start
undef_vector:
    .long   undef_handler
swi_vector:
    .long   swi_handler
prefech_vector:
    .long   prefetch_handler
data_abort_vector:
    .long   data_abort_handler
irq_vector:
    .long   IRQ_Handler
fiq_vector:
    .long   fiq_handler

また，vector_ref_tblをRAM上に配置した場合には，カーネル管理外の例外と
して，vector_ref_tblに直接ユーザーのハンドラを登録する関数を用意する．
なお，vector_ref_tblをフラッシュメモリに配置した場合は，このシステムコ
ールは正常に動作しないので，注意が必要である．

      void x_install_exc(EXCNO excno, FP exchdr)

ディフォルトのvector_ref_tblの登録内容は上に示した通りである．startと
IRQ_Handler以外は，core_support.Sに定義されており，ARMアーキテクチャ毎
に処理が異なる．

ARMv4,ARMv5では，スーパーバイザーモードに移行して，スタック上にコンテ
キストを積んだ後，元のモードに戻り，r0に例外発生時のpc, r1に例外発生時
のcpsr, r2にCPU例外ハンドラ番号を入れて，ターゲット依存部で定義する
target_exc_handler へジャンプする．

ARMv6,ARMv7では，lr(戻り先)とspsr(cpsr_svc)をスーパーバイザーモードの
スタック上に積んだ後，r2にCPU例外ハンドラ番号を入れて，ターゲット依存
部で定義する target_exc_handler へジャンプする．


●ベクタの保護

前述の通りARMのベクタ（vector_table）は，0x00000000 に配置する必要があ
る．通常はこのアドレスにはROMやフラッシュメモリ等の不揮発性のメモリが
割り当てられるが，ターゲットによっては，RAMをリマップすることが可能で
ある．RAMを0x00000000 を配置して，ベクタ（vector_table）を配置すると，
ユーザープログラムでベクタを書き換えることが可能となるので注意が必要で
ある．特にユーザープログラムによる，NULLポインタによるアクセスにより書
き換えられる可能性が高い．安全性を高めるためには，ターゲット依存で次の
対策を行うことを推奨する．

  ・リマップを行わず，不揮発性メモリにベクタを置く．
  ・MMUによりベクタの領域を書き込み禁止とする．
  ・High Vector機能を使用し，ベクタを0x00000000以外に配置する．


●例外フレーム（CPU例外ハンドラへの引数）

FMPカーネルの仕様では，CPU例外ハンドラの引数には，CPU例外に関する情報
を記憶している領域（例外フレーム）の先頭番地が渡される．そのため，CPU
例外発生時のコンテキストを保存したスタックへのポインタを渡す．

例外フレームは，ARMアーキテクチャ毎に異なり，ARMv4/ARMv5では次のように
なる．このうち，R0,R1,R2,R3,ipに関しては，ARMプロセッサ依存部で設定さ
れる．その他の値は，ターゲット毎の target_exc_handler で作成する．例外
前の割込み優先度マスクは，PRI(int_t)型の外部表現である．

           例外フレーム(ARMv4-5)            offset
      ------------------------------
     |  例外前のネストカウント      |  0  <-- p_excinf
      ------------------------------
     |  例外前の割込み優先度マスク  |  1
      ------------------------------
     |        例外前のCPSR          |  2
      ------------------------------
     |            R0                |  3
      ------------------------------
     |            R1                |  4
      ------------------------------
     |            R2                |  5
      ------------------------------
     |            R3                |  6
      ------------------------------
     |            IP                |  7
      ------------------------------
     |          LR_svc              |  8
      ------------------------------
     |     例外前のPC(戻り先)       |  9
      ------------------------------

ARMv6/ARMv7では次のようになる．このうち，R0,R1,R2,R3,IP,LR_svc,例外前
のPC,例外前のCPSRに関しては，ARMプロセッサ依存部で設定される．その他の
値は，ターゲット毎の target_exc_handler で作成する．例外前の割込み優先
度マスクは，PRI(int_t)型の外部表現である．

           例外フレーム(ARMv6-7)            offset
      ------------------------------
     |  例外前のネストカウント      |  0  <-- p_excinf
      ------------------------------
     |  例外前の割込み優先度マスク  |  1
      ------------------------------
     |            R0                |  2
      ------------------------------
     |            R1                |  3
      ------------------------------
     |            R2                |  4
      ------------------------------
     |            R3                |  5
      ------------------------------
     |            IP                |  6
      ------------------------------
     |          LR_svc              |  7
      ------------------------------
     |     例外前のPC(戻り先)       |  8
      ------------------------------
     |        例外前のCPSR          |  9
      ------------------------------

○割り込みの取り扱い

●カーネル管理内/外の割込み

IRQをカーネル管理内，FIQをカーネル管理外の割込みとする．

●CPUロックフラグ

CPUロックフラグとして，ステータスレジスタのIRQビットを用いる．すなわち
，CPUロック状態では，IRQビットをセットし，カーネル管理内の割込みを禁止
し，CPUロック解除状態では，IRQビットをクリアする．

●割込みロックフラグ

割込みロックフラグとしては，CPSRのFIQビットとIRQビットを用いる．割り込
みロック状態では，IRQビットとFIQビットをセットする．


=====================================================================
                ターゲット依存部開発者向けの情報
=====================================================================
○スタートアップルーチンについて

ARMプロセッサ依存部で用意さているスターアップルーチン（start.S）では，
sta_ker()を呼び出す前に変数を用いた同期を行っている．ターゲットによっ
ては，起動時に有効なメモリがなく，この手法が用いることができない場合が
ある．その場合は，ターゲット依存部で別途別の手法を用いたスタートアップ
ルーチンを用意すること．

○アーキテクチャ指定

アーキテクチャを次のマクロで指定する．

  __TARGET_ARCH_ARM

それぞれのアーキテクチャと設定する値は次の通りである．

  ARMv4 : 4
  ARMv5 : 5
  ARMv6 : 6
  ARMv7 : 7

○コンテキストの判定

カーネルは，割り込み/例外の入り口で，カーネル内のカウント用の変数（
excpt_nest_count）をカウントアップし，出口でカウントダウンする．そのた
め，excpt_nest_count が0の場合はタスクコンテキスト，1以上の場合は非タ
スクコンテキストと判断する．

○例外エントリ処理

各例外のエントリ処理は要因毎にカーネルで個別に持つ．JSPではルーチンを
共有していたが，ルーチンを共有化すると，例外発生後，一時的にレジスタを
退避させるために一時領域を用いる必要があるため，個別に持つように変更し
た．

各例外のエントリ処理では以下の処理を行う．

 ・タスク動作時のモードに移行（スタックを切り替える）
 ・r0-r3,ip,lr,pcを保存（PCはダミー）
 ・元のモードに戻る
 ・r0にlr，r1にspsrを，r2にCPU例外ハンドラ番号を入れる
 ・target_exc_handlerへジャンプ

target_exc_handler はターゲット毎に用意する．ターゲット毎に用意するの
は，前述の例外フレームに例外前の割込み優先度マスクが含まれており，この
割込み優先度マスクの扱いがターゲット毎に異なるためである．

target_exc_handler では，前述の例外フレームのフォーマットに従って例外
フレームを作成して，その先頭番地を引数にして，対応するCPU例外ハンドラ
を呼び出す．

FIQのエントリ処理（fiq_handler）については，ターゲット依存部側で用意す
る場合には，それぞれ，以下のマクロを定義すれば，ARM依存部側のエントリ
処理が無効となる．

     TARGET_FIQ_HANDLER


○アイドル処理

実行するべきタスクがない場合は，ディスパッチャーで割込みを許可して，割
込みを待つ（dispatcher_2）．ARM依存部のコードでは，次のようになってい
る．

       割込みを許可
       nop
       割り込み禁止

ターゲット依存で，上記の処理の代わりに，省電力モード等に移行する処理を
記述したい場合には，ターゲット依存部で，OMIT_DEFAUL_IDLEを定義し，代わ
りに実行した処理を asm_target_idle というアセンブラマクロとして記述す
る．なお，asm_target_idle の記述にあたっては，次のレジスタは使用できな
い．

       r0, r1, r2, r3, sp

アセンブラマクロはC言語記述中に展開するとエラーとなる．pr_support.S で
は，TOPPERS_ASM_MACRO というマクロを定義しているため，ターゲット依存部
で asm_target_idle アセンブラマクロを定義する際には，TOPPERS_ASM_MACRO
を条件コンパイルの条件として用いること．


○CPSRに常にセットする値

CPSRの変更時，常にセットするパターンを CPSR_ALWAYS_SET として，ターゲ
ット依存部で定義可能である．


○ARMコアコントロールブロックのセクションの指定

プロセッサ毎の管理情報である，ARMコアコントロールブロックのセクション
を指定可能である．指定は，ターゲット依存部のパス2のテンプレートファイ
ルで以下の名前の連想配列でプロセッサIDをINDEXとして指定する．

  PRC_SECTION_ACCB[]


○自プロセッサへのデータ構造へのアクセスマクロ

ターゲット依存部では，プロセッサID等によるプロセッサを判別機能を用いて，
自プロセッサのデータ構造へのアクセスを実現するアセンブラ用のマクロを
target_asm.inc もしくはそこからインクルードされるファイルに用意する必
要がある．

●my_core_index rx

自プロセッサ用のプロセッサINDEXへのアクセスマクロ，rxに自プロセッサの
プロセッサIDが返される．

●my_pcb rx, ry

自プロセッサ用のPCBへのアクセスマクロ，rxに自プロセッサのPCBへのポイン
タが返される，ryはスクラッチレジスタである．

●my_istkpt rx, ry

自プロセッサ用のISTKPTへのアクセスマクロ，rxに自プロセッサのISTKPTへの
ポインタが返される，ryはスクラッチレジスタである．


○ディスパッチ用のプロセッサ間割込みハンドラのバイパス処理

ディスパッチ用のプロセッサ間割込みが入った場合に，割込みハンドラ処理の
バイパスして，ディスパッチャを呼び出すことが可能である．以下のマクロを
定義して，ret_int_ipi_dispatch を呼び出させばよい．

  USE_IPI_DIS_HANDER_BYPASS

○Thumb Mode 用のコンパイル

カーネルを Thumb Mode 用にコンパイルする場合は，マクロ
__thumb__ を定義すること．

○TrustZoneのサポート

SafeGを用いてSecure側で実行するコンフィギュレーションをサポートする．
この機能を有効にするには，以下のマクロを定義すること．

 TOPPERS_SAFEG_SECURE : TrustZoneのSecure側で実行

=====================================================================
                             変更履歴
=====================================================================
2012/10/19
・TrustZoneのサポート．

2012/03/30
・start.S
  ・TOPPERS_OMIT_DATA_INIT をサポート．

2012/03/09
・core_support.S
  ・toppers_asm_custom_idleの前後で使用するレジスタを変更．この変更に
    より，toppers_asm_custom_idle で関数呼び出しをする場合は，アセンブ
    ラレベルでのレジスタの保存が必要なくなった．

2012/02/24
・core_config.h/core_config.c
  ・共通部で initialize_exception() は通常の関数としてプロトタイプ宣言
    されているため，インライン関数ではなく，通常の関数として宣言するよ
    う変更．

2011/05/03
・ASP 1.7.0 への追従．
  ・オフセットファイルの生成方法をコンフィギュレータを用いる方法に変更．

2011/03/10
・ASP 1.7.0 への追従．
・chg_ipmの仕様変更への追従．

2011/03/03
・sil_dly_nse()でインラインアセンブラで_sil_dly_nseの呼び出し記述に
  "lr"をクローバレジスタとして指定していない問題を修正．

2011/03/02
・_sil_dly_nse をリネームしないように変更．

2010/11/02
・起動時の同期方法を変更．
  デバッガを使う場合，前の実行のメモリが残っているため正しく同期できな
  い場合があった．同期用の変数をコア毎に持ち，同期後に初期化するように
  変更．

2010/10/11
・Thumb Mode 用のsrの設定・参照関数の追加．

2010/07/26
・VECTOR_KERNELの廃止．

2010/02/26
・ARMv6/7のサポート
  ARMv6/7を指定した場合は，割込み・例外の出入り口をsrs/rfeに変更．
  この変更に伴い，例外フレームもARMv4/5とは異なる構造となる．

2010/01/27
・core_cfg1_out.hの内容の整理．

2009/11/20
・スタートアップルーチンでマスタプロセッサをTOPPERS_MASTER_PRCIDを見て
  判定するように変更．

2009/10/16
・アセンブラファイル中の分岐命令を AAPCS推奨に変更．
  mov pc, xx -> bx pc

2009/09/15
・ディスパッチ用のプロセッサ間割込みハンドラのバイパス処理を追加

2009/07/14
・「CPU例外番号」ないしは「例外番号」を「CPU例外ハンドラ番号」に統一．
・例外フレーム入れる例外前の割込み優先度マスクの値をターゲット依存の
  値から外部表現に変更．

2009/02/03
・マルチプロセッサ向けの説明を追加．

以上
